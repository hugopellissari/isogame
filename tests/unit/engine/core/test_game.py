import pytest
from unittest.mock import MagicMock, call
from engine.core.game import Game
from engine.core.system import System
from engine.core.cqrs import BaseCommand, BaseEvent

# --- Mocks ---

class MockTerrain:
    """Pass-through mock for terrain."""
    pass

class MockEntityMap:
    """Pass-through mock for entity storage."""
    pass

class TestCommand(BaseCommand):
    pass

class TestEvent(BaseEvent):
    pass

class TrackingSystem(System):
    """A system that logs when its update method is called."""
    def __init__(self, log_list):
        self.log_list = log_list

    def update(self, game, dt):
        self.log_list.append("system_update")
        # Simulate a system generating an event during the update
        game.enqueue_event(TestEvent())

# --- Fixtures ---

@pytest.fixture
def empty_game():
    """Returns a fresh Game instance with mocked dependencies."""
    return Game(
        terrain=MockTerrain(), 
        entities=MockEntityMap(), 
        systems=[]
    )

# --- Tests ---

def test_initialization(empty_game):
    """Ensure the game starts with empty queues and valid components."""
    assert empty_game.command_queue == []
    assert empty_game.event_queue == []
    assert isinstance(empty_game.terrain, MockTerrain)
    assert isinstance(empty_game.entities, MockEntityMap)
    assert empty_game.systems == []

def test_enqueueing_logic(empty_game):
    """Test that helper methods correctly append to the queues."""
    cmd = TestCommand()
    evt = TestEvent()

    empty_game.enqueue_command(cmd)
    empty_game.enqueue_event(evt)

    assert len(empty_game.command_queue) == 1
    assert empty_game.command_queue[0] == cmd
    
    assert len(empty_game.event_queue) == 1
    assert empty_game.event_queue[0] == evt

def test_tick_execution_order():
    """
    The 'Holy Grail' test for the Game loop.
    Verifies that Tick() runs:
    1. Commands
    2. Systems
    3. Events
    In that exact order.
    """
    execution_log = []

    # 1. Setup Handlers to track execution
    def handle_command(game, cmd):
        execution_log.append("command_processed")

    def handle_event(game, evt):
        execution_log.append("event_processed")

    # 2. Setup System
    # The system will log its update AND enqueue an event
    system = TrackingSystem(execution_log)

    # 3. Setup Game
    game = Game(MockTerrain(), MockEntityMap(), systems=[system])
    
    # Register our trackers
    game.command_processor.register_handler(TestCommand, handle_command)
    game.event_processor.register_handler(TestEvent, handle_event)

    # 4. Enqueue initial state
    game.enqueue_command(TestCommand())

    # 5. RUN TICK
    game.tick(dt=0.16)

    # 6. Verify The Order
    expected_order = [
        "command_processed",  # Step 1: Intent
        "system_update",      # Step 2: Simulation (System generates event here)
        "event_processed"     # Step 3: Reality (Event generated by system is handled)
    ]
    
    assert execution_log == expected_order

def test_tick_clears_queues(empty_game):
    """Ensure that queues are empty after a tick to prevent double-processing."""
    # Setup a dummy command handler so the processor doesn't complain
    empty_game.command_processor.register_handler(TestCommand, lambda g, c: None)
    
    empty_game.enqueue_command(TestCommand())
    empty_game.enqueue_event(TestEvent())

    # Pre-check
    assert len(empty_game.command_queue) == 1
    assert len(empty_game.event_queue) == 1

    empty_game.tick(0.1)

    # Post-check
    assert len(empty_game.command_queue) == 0
    assert len(empty_game.event_queue) == 0

def test_system_dt_propagation():
    """Ensure the delta_time (dt) is correctly passed down to systems."""
    mock_system = MagicMock(spec=System)
    game = Game(MockTerrain(), MockEntityMap(), systems=[mock_system])

    dt_value = 0.5
    game.tick(dt_value)

    # Verify update was called with specific arguments
    mock_system.update.assert_called_once_with(game, dt_value)
